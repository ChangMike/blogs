---
layout: post
title: Spring资源加载
categories: Spring
date:   2013-11-17 14:31:01 +0800

---

* content
{:toc}


##### [编辑](https://github.com/ChangMike/blogs/edit/master/_posts/2013-11-17-Spring资源加载.md){:target="_blank"}
------------------------
1. Resource接口   
JDK没有提供从Web容器上下文及classpath中获取资源的操作类。鉴于此，spring设计了Resource接口，该接口的实现类ServletContextResource从Web应用根目录下访问资源、ClassPathResource从类路径下访问资源。
```
    public static void main(String[] args) throws IOException {
        ClassPathResource resource1 = new ClassPathResource("config/my.xml");
        File file = resource1.getFile();
        /**
         * 如果资源文件在jar包中，因为jar本来就是一个文件，
         * 所以不能使用Resource.getFile()获取文件中的文件，
         * 可以使用Resource.getInputStream()获取jar中的文件
         */
        InputStream inputStream1 = resource1.getInputStream();
    }
```
2. ResourceLoader接口   
ResourceLoader采用了策略模式，通过传入的地址前缀，自动选择Resource实现类。
```
    public static void main(String[] args) throws IOException {
        ResourcePatternResolver resourceLoader = new PathMatchingResourcePatternResolver();
        Resource[] resources = resourceLoader.getResources("classpath*:*.xml");
        if (resources != null) {
            for (int i = 0; i < resources.length; i++) {
              System.out.println(resources[i].getFilename());
            }
        }
    }
```
- 资源地址可以使用的前缀有：1. classpath:  2. classpath*:   3.file:   4.http://    5.ftp://   6.没有前缀
- 资源地址支持三种通配符：？匹配文件名中的一个字符；* 匹配文件名中任意字符；** 匹配多层路径
  3. ResourceLoader的实现类PathMatchingResourcePatternResolver
  ```
  public class PathMatchingResourcePatternResolver implements ResourcePatternResolver {}
  public interface ResourcePatternResolver extends ResourceLoader {
    // 根据classpath*:查询资源
    String CLASSPATH_ALL_URL_PREFIX = "classpath*:";
    // 支持通配符的资源路径表达式
    Resource[] getResources(String locationPattern) throws IOException;
  }
  public interface ResourceLoader {
    // 根据classpath:查询资源
    String CLASSPATH_URL_PREFIX = "classpath:";
    Resource getResource(String var1);
    ClassLoader getClassLoader();
  }
  
  ```
